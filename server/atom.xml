<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tech & Life</title>
 <link href="http://shawzt.github.com/atom.xml" rel="self"/>
 <link href="http://shawzt.github.com"/>
 <updated>2013-01-11T15:24:21+08:00</updated>
 <id>http://shawzt.github.com</id>
 <author>
   <name>shawzt</name>
   <email>gmail.com</email>
 </author>

 
 <entry>
   <title>让异地恋不再辛苦</title>
   <link href="http://shawzt.github.com/blog/01-06-2013/forlove"/>
   <updated>2013-01-06T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/01-06-2013/forlove</id>
   <content type="html">&lt;p&gt;牛郎织女的故事凄美动人，天地遥遥相隔，每年七夕相会。这样的爱情虽然绝美，但对于普通人来说，未免残酷。就像异地恋，远远望去看似美好，可当我们要靠近它时，就发现不那么容易了。爱情固然美好，可现实终究是现实。异地恋具有挑战性，具有危险性，不是每个人都能坚持到最后。&lt;/p&gt;

&lt;p&gt;随着时代的进步，由于个人发展的需要，因工作或学业等原因导致两地分居的恋人逐渐增多；但相比古代，我们生活在高速发达的信息社会，电话、网络等联络方式和便捷的交通方式减少了异地恋的相思之苦；然而另一方面，现代人面临的诱惑和选择也在增多，异地恋的挑战性和危险性也随之增大，到底有多少人能够坚持到修成正果的那一天呢？&lt;/p&gt;

&lt;p&gt;爱情不仅仅是甜言蜜语，更多的是责任与付出！有句话说得好&quot;如果我不曾为你我的未来而努力，那我拿什么证明我爱着你？&quot;,但是爱情也不是通过一个人努力的奋斗与付出就可以开花的,爱需要沟通,需要要坦诚的沟通!下面的一些小建议,或许可以让异地恋的爱情不再那么辛苦。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、一定要让彼此的沟通很畅通
分隔两地的爱情最怕赌气和误解。长时间的赌气和误解，会让两人感情淡漠，还有可能会让挖墙角者
趁虚而入。凡事说清楚，该认错就认错。 生气了，你说出他（她）具体哪点做得不好，告诉他（她）
你不喜欢这种方式；但是你如果赌气说“我不管你了，你也别管我”“我不知道还会不会喜欢别人”之类
的话，估计只能打击对方的信心，造成不愉快的气氛。长时间的冷战只会让感情降温！沟通才是最好
的解决方法！
2、彼此一定要信任，认定能在一起
分隔两地的爱情，一定要让信仰和信念支撑你们。时常的迷茫，对未来没有信心，就会动摇感情。
要不时地去向对方表达这种信心和信念：虽然现在你们不在一起，但你一直在努力，为你们日后美满
的生活奋斗。 当你没有了对你们爱情的憧憬，甚至抱着走着看的态度，那只能说是你们的悲哀了。没
有坚定信念的爱情，总有一天会在各种诱惑中迷失！ 
3、用短信、电话、网络保持最及时的联系
失去联系、不能及时沟通，会让对方焦虑不安。久而久之就会产生猜忌，影响两个人的感情。而短信、
电话、网络的及时到达，通过虚拟能感受情人在身边的感觉。保持一定的见面频率，最好两三个月能
见一次。相思之苦也是需要释放的，几日的甜蜜，就把过去几个月的相思给补回来了。
如果给对方打电话或发短信得不到回应，你肯定由甜美变得焦急（甚至愤怒了，但是这时你应该安心做
你的事，要理解他（她）不回你电话，必定有他（她）的不方便。但是反过来，如果对方给你打电话或
发短信，无论再不方便，只要电话在身边，至少给对方个短信别让
他（她）着急。 如今信息传送很是便捷，一定要让对方知晓你现在的状况，不要让等待和猜忌腐蚀
你们的爱情！
4、用心保持激情
小别胜新婚，两地分居后的短暂相逢定会让彼此情意绵绵，除此之外，现在也有很多新鲜玩意也可以
增加异地恋情的质量。 闲暇之余，尽你所想，给你的宝贝儿来点惊喜，比如网上送个小卡片，为她订
个小礼物等等。 或许这些东西在当时看来是小动作，但是日后回忆的话，它的余味远远大于本身。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span style=&quot;margin-left:100px&quot;&gt;&lt;img src=&quot;/assets/images/forlove.jpg&quot; alt=&quot;异地恋&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>newyear_2013</title>
   <link href="http://shawzt.github.com/blog/01-01-2013/new_year_2013"/>
   <updated>2013-01-01T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/01-01-2013/new_year_2013</id>
   <content type="html">&lt;p&gt;2013，新的一年从今天开始！
新的一年——“7分计划+2分梦想+1分空白”&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2012—回首</title>
   <link href="http://shawzt.github.com/blog/12-31-2012/past_year_2012"/>
   <updated>2012-12-31T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-31-2012/past_year_2012</id>
   <content type="html">&lt;p&gt;&lt;font face=&quot;华文行楷&quot; size=&quot;4&quot; color=&quot;green&quot;&gt;2012，地球没有毁灭，留下的是珍贵的回忆！&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;回想过去的2012，有失有得、有哭有笑、有收获亦有遗憾。&lt;br/&gt;
我的2012，平淡却不失精彩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;春节&lt;/strong&gt;，一家人欢喜团聚的佳节，却因为我和丫头的事情而使得家人无法开心。那一次，因害怕失去一个人而哭。那一次，脑海中都是丫头如何关心、支持我的场景（丫头，感谢你。感谢你陪我为了保研坐了一夜无座的火车去杭州、感谢你在我迷茫失落的时候给我鼓励、感谢你提醒我不要因为一次摔倒而丧失再次站起来的勇气~~~），最终这次危机在父母的谅解和上天的眷顾下得以度过。那一次，我坚持了——&lt;font face=&quot;华文中宋&quot; color=&quot;chocolate&quot;&gt;牵了手就不会轻易松开&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;年后回校&lt;/strong&gt;，虽然之前的事情已经解决并和丫头说明了，但是我能体会到丫头心里的不踏实，即使是在陪着她去南京找工作、租房的那段时间。年后回到学校，就是毕业倒计时了。一边准备着两个人的毕业设计，一边帮着丫头投简历、找工作，时间很快就四月份了。那段找工作的日子，累坏了丫头。为了能赶上招聘会和约定的笔试，我俩带着个行李箱跑遍了差不多整个南京城，记得有一天两人都只吃了一个包子……付出终会有收获：在疲惫时快要放弃的时候，收到了面试通知；在等待中快要离开的时候，收到了offer。那一次，我明白了——&lt;font face=&quot;华文中宋&quot; color=&quot;chocolate&quot;&gt;付出是为了对方能够过得更好&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;毕业离校&lt;/strong&gt;，四年的大学生活就此结束。痛苦和快乐，在踏出校门的那一刻都成为了若水园里的回忆。当初入学时，很不理解学长学姐们离开时的伤感。当我也成为那幅画中的他时，当初的期盼成了无言的伤感，不舍和祝福成了拥抱和送别。乘车离去，若水园我将何时再回？那一次，我理解了——&lt;font face=&quot;华文中宋&quot; color=&quot;chocolate&quot;&gt;珍惜你所拥有的最珍贵的今天&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分开奋斗&lt;/strong&gt;，毕业后我和丫头不得不分开而各自努力。我来了宁波读书，她留在了南京工作。大学里，一起吃饭、一起自习、一起逛街成了奢侈的期盼。我默默地在心里许下诺言——不离不弃。分别时的不舍与烦躁到如今的信任和坚持，我们的感情也变得越来越稳固。那一次，我体会了——&lt;font face=&quot;华文中宋&quot; color=&quot;chocolate&quot;&gt;默默坚守一份爱&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;&lt;font face=&quot;华文行楷&quot; color=&quot;green&quot; size=&quot;4&quot;&gt;逝去的成了我们珍贵的回忆，珍惜你所有拥有的！&lt;/font&gt;&lt;br/&gt;
&lt;span style=&quot;margin-left:500px&quot;&gt;&lt;font face=&quot;仿宋&quot; color=&quot;brown&quot;&gt;于2012/12/31 23:59:59&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu下Sublime Text2的中文输入解决方法</title>
   <link href="http://shawzt.github.com/blog/12-26-2012/sublime_text_InputHelper"/>
   <updated>2012-12-26T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-26-2012/sublime_text_InputHelper</id>
   <content type="html">&lt;p&gt;还没有Sublime Text2？&lt;a target=&quot;blank&quot; href=&quot;http://www.sublimetext.com/2&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下面是InputHelper插件的安装过程：  
    1. 输入Ctrl+Shift+P，调出命令面板--&amp;gt;输入install，打开插件安装管理器；  
    2. 输入InputHelper查找到要安装的插件，选中回车即可安装；  
    3. 安装完毕后，可通过快捷键Ctrl+Shift+Z调用插件，即可输入中文。
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenStack组件说明之二</title>
   <link href="http://shawzt.github.com/blog/12-24-2012/openstack-component_2"/>
   <updated>2012-12-24T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-24-2012/openstack-component_2</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;3. 镜像服务——Glance&lt;/strong&gt;&lt;br/&gt;
Glance是OpenStack中的一个虚拟机镜像的存储、注册、查询和检索的系统。Glance被设计成可以使用多种后端存储的方式，其目前支持的镜像存储方式有：本地文件系统；Swift；S3；Http只读存储。Glance的设计方式遵循以下思想：基于组件的架构——便于快速增加新特性；高可用性——支持大负荷；容错性——独立进程避免串行错误；开放标准——提供社区API参考实现。 Glance的结构如下图所示：&lt;img src=&quot;/assets/images/Glance_architecture.png&quot; alt=&quot;Glance结构&quot; /&gt; &lt;br/&gt;
&lt;strong&gt;4. 认证服务——Keystone&lt;/strong&gt;&lt;br/&gt;
Keystone为所有的OpenStack组件提供认证和访问策略服务。它依赖自身基于Identity API的REST系统进行工作，主要对Swift、Glance、Nova等进行认证与授权。Keystone的认证管理过程见下图：&lt;br/&gt;
&lt;img src=&quot;/assets/images/keystone.png&quot; alt=&quot;Keystone认证管理&quot; /&gt;&lt;br/&gt;
Keystone采用基于用户名/密码和基于令牌的两种授权方式，并提供以下三种服务：令牌服务、目录服务和策略服务。在提供认证和授权服务过程中，涉及以下概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务

&lt;pre&gt;&lt;code&gt;  任何通过Keystone进行连接或管理的组件，如Glance就是Keystone的服务。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;服务入口

&lt;pre&gt;&lt;code&gt;  指定的端口和专属URL，每个OpenStack均拥有唯一的一个服务入口。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;角色

&lt;pre&gt;&lt;code&gt;  为维护云安全而设定的权限分组。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;用户

&lt;pre&gt;&lt;code&gt;  Keystone授权使用者。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;5. 管理接口——Horizon&lt;/strong&gt;&lt;br/&gt;
Horizon是一个模块化的Django Web应用程序，为终端用户和系统管理员提供界面来管理OpenStack服务。它可以控制实例、管理镜像、创建密钥对、操作卷及Swift容器等，同时用户可以在Horizon中使用终端直接访问实例。界面下图。&lt;br/&gt;
&lt;img src=&quot;/assets/images/horizon_web.png&quot; alt=&quot;OpenStack控制面板&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备注：组件之间的交互见&lt;a target=&quot;blank&quot; href=&quot;/blog/12-21-2012/openstack_review/#component&quot;&gt;交互图&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenStack组件说明之一</title>
   <link href="http://shawzt.github.com/blog/12-23-2012/openstack-component_1"/>
   <updated>2012-12-23T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-23-2012/openstack-component_1</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;1. 计算服务——Nova&lt;/strong&gt; &lt;br/&gt;
Nova是OpenStack的弹性控制器，OpenStack云实例生命期所需的各种动作都将由Nova支持和处理。这意味着Nova负责管理所创建的云平台的计算资源、网络、授权及测度。Nova本身并不提供任何虚拟能力，它使用libvirt API与虚拟机的宿主机进行交互。Nova通过Web服务API对外提供处理接口，而且这些接口与Amazon的Web服务接口是兼容的。 &lt;br/&gt;
Nova的主要功能和特点有：管理实例生命周期；管理计算资源；管理网络和授权；API支持；异步连续通信；多类型宿主支持。Nova包含的主要部件及其作用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;API服务器（Nova-API）

&lt;pre&gt;&lt;code&gt;  该服务器提供云平台与外界交互的接口，是外界用户对云平台实施管理的唯一通道。
  通过使用Web服务来调用各种API并通过消息队列把请求发送至云内目标设施进行处理。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;消息队列（Rabbit MQ Server）

&lt;pre&gt;&lt;code&gt;  OpenStack内部在遵循AMQP的基础上采用消息队列进行通信。Nova对请求应答进行异步调用，
  当接收一个请求后便立即触发回调，避免了长时间的等待，使整个系统的运行更加高效。   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;运算工作站（Nova-Compute）

&lt;pre&gt;&lt;code&gt;  该部件的主要任务是通过消息队列接收请求并执行，实现对实例进行操作和管理。    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;网络控制器（Nova-Network）

&lt;pre&gt;&lt;code&gt;  网络控制器用于主机的网络配置，如IP地址分配、VLAN配置、安全群组设定以及
  计算节点配置。   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;卷工作站（Nova-Volume）

&lt;pre&gt;&lt;code&gt;  卷工作站用于管理基于LVM的实例卷，如为实例创建、删除、附加以及分离卷。该部件
  提供了一种保持实例持续存储的能。    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;调度器（Nova-Scheduler）

&lt;pre&gt;&lt;code&gt;  该部件以守护进程的方式运行，根据调度算法选择恰当的运算服务器，负责把Nova-API
  调用送达给目标。    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;2. 存储服务——Swift&lt;/strong&gt;&lt;br/&gt;
Swift是一个可扩展的对象存储系统，使OpenStack具备了分布式的、存储持续虚拟对象的能力，类似于AWS的S3简单存储服务。同时，Swift具有跨节点百级对象的存储能力，内建了冗余和失效备份管理机制，支持多种对象的存储，如存档、图像、视频等，对大数据和大容量的支持更高效。&lt;br/&gt;
Swift的功能和特点有：海量数据存储；大容量对象存储；数据冗余管理；备份归档能力；支持流媒体处理；良好的可伸缩性。Swift包含的主要部件及其作用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代理服务器

&lt;pre&gt;&lt;code&gt;  代理服务器是接收外界请求的岗哨，它检测请求者的合法性及路由请求。同时，代理服务器
  也处理实体转移、故障切换时的路由请求。用户都是通过Swift-API与代理服务器进行交互。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;对象服务器

&lt;pre&gt;&lt;code&gt;  对象服务器负责处理本地存储中对象数据的存储、检索和删除。其中，对象都是文件系统
  中存放的典型的二进制文件，具有扩展文件属性的元数据。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;容器服务器

&lt;pre&gt;&lt;code&gt;  容器服务器作用是：列出一个容器中的所有对象，默认对象列表将存储为SQLite文件；统计
  容器中包含的对象数量及容器的存储空间耗费。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;账户服务器

&lt;pre&gt;&lt;code&gt;  其作用是存储容器清单并记录容器中的对象。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;索引环

&lt;pre&gt;&lt;code&gt;  该部件记录Swift中物理存储对象的位置信息。是真实物理存储位置的实体名的虚拟映射。  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;备注：组件之间的交互见&lt;a target=&quot;blank&quot; href=&quot;/blog/12-21-2012/openstack_review/#component&quot;&gt;交互图&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenStack架构简介</title>
   <link href="http://shawzt.github.com/blog/12-21-2012/openstack_review"/>
   <updated>2012-12-21T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-21-2012/openstack_review</id>
   <content type="html">&lt;p&gt;云计算的相关概念介绍见我的
&lt;a target=&quot;blank&quot; href=&quot;/blog/12-19-2012/cloud_computing/&quot;&gt;云计算——简介&lt;/a&gt;  &lt;br/&gt;
OpenStack是一个由美国国家航空航天局（NASA）和托管服务提供商Rackspace合作开发的，以Apache许可证授权的自由软件和开源项目。作为IaaS层次软件，OpenStack由几个重要组件构成，旨在为企业或个人提供建设和管理公用及私有云的软件。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;OpenStack技术支持&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用Python语言编写&lt;/li&gt;
&lt;li&gt;整合Tornado网页服务器&lt;/li&gt;
&lt;li&gt;Nebula运算平台&lt;/li&gt;
&lt;li&gt;使用Twisted软件框架&lt;/li&gt;
&lt;li&gt;遵循Open Virtualization Format、AMQP、SQLAlchemy等标准&lt;/li&gt;
&lt;li&gt;支持KVM、Xen、VirtualBox、VMware、LXC等虚拟机软件。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;&lt;strong&gt;OpenStack企业支持&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;硬件厂商有AMD、Intel、惠普以及戴尔等&lt;/li&gt;
&lt;li&gt;微软将在Windows Server R2中与OpenStack整合&lt;/li&gt;
&lt;li&gt;Ubuntu在11.04版本中加入了OpenStack&lt;/li&gt;
&lt;li&gt;思科在2011年2月加盟OpenStack项目，重点研制OpenStack的网络服务&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;新浪、华为及相关高校也参与研究、积极宣传，共同创建了公益性的OpenStack体验、测试和开发
平台——&lt;a target=&quot;blank&quot; href=&quot;http://stacklab.org/&quot;&gt;Stack Lab&lt;/a&gt;实验室，促进OpenStack在国内的普及。在众多企业和高校的加盟和支持，营造了
一个良好的OpenStack社区，进一步推动了OpenStack的发展。&lt;/pre&gt;


&lt;h4&gt;&lt;strong&gt;OpenStack基本架构&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;OpenStack包括一组由社区维护的开源项目，主要有提供计算服务的Nova、提供存储服务的Swift、提供镜像服务的Glance、提供认证服务的Keystone以及提供UI服务的Horizon。OpenStack的基本架构见下左图所示，组件之间的交互见下右图。     &lt;br/&gt;
&lt;img src=&quot;/assets/images/OpenStack_architecture.png&quot; alt=&quot;OpenStack基本架构&quot; /&gt;
&lt;img src=&quot;/assets/images/OpenStack_communication1.png&quot; alt=&quot;OpenStack组件交互&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;component&quot;&gt;OpenStack组件交互图&lt;/h5&gt;


&lt;p&gt;&lt;img src=&quot;/assets/images/openstack_communication2.png&quot; alt=&quot;OpenStack组件交互&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>云计算——简介</title>
   <link href="http://shawzt.github.com/blog/12-19-2012/cloud_computing"/>
   <updated>2012-12-19T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-19-2012/cloud_computing</id>
   <content type="html">&lt;p&gt;云计算是如今很火的一个技术名词，并且在IT行业掀起了新的技术浪潮，开辟出新的研究领域，引领着新兴产业发展方向。那么什么是云计算？它又能干些什么？如下是我近期学习的一些知识整理和理解（能力有限，还请指正偏差和错误~~~)。&lt;/p&gt;

&lt;h3&gt;概念&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97&quot;&gt;云计算&lt;/a&gt;是一种通过互联网以服务的方式提供动态可伸缩的虚拟化资源的计算模式。用户不再需要了解基础设施的细节、不必具有相应的专业知识，无需开发维护，只需要通过浏览器等软件访问云计算服务商提供的公共或个性化应用。而服务商将按客户的需求提供符合要求的各项服务，如存储、数据分析、社交等。&lt;br/&gt;
&lt;img src=&quot;/assets/images/cloud_computing.png&quot; alt=&quot;云概念&quot; /&gt;
&lt;img src=&quot;/assets/images/cloud_applications.jpg&quot; alt=&quot;云计算&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;特征&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;基于云计算的服务应具有以下特征：  
- 资源虚拟化
- 快速部署  
- 按需获取服务及计费   
- 自由地通过网络存取   
- 共享的资源池
- 动态可伸缩地扩展  
- 服务可被监控和量测   
- 减轻终端负担
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;服务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;云计算包括以下三大部分的服务：
- 基础设施即服务[IaaS]
    客户通过Internet即可获得服务商通过虚拟化技术提供的IT基础设施服务。
- 软件即服务[SaaS]
    客户无需购买软件，只需通过Web访问的方式来使用通过互联网提供的软件。
- 平台即服务[PaaS]
    服务商将软件研发的平台作为一种服务，以SaaS的模式提供给客户。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;部署&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;云计算服务提供的方式主要有以下三种：
- 公用云[Public Cloud]
    服务通过网络和第三方服务供应者，开放给客户使用。注意，“公用”不代表免费，
    也不代表客户信息的公开。
- 私有云[Private Cloud]
    在私有云服务中，供应者及使用者拥有更强的掌控力，且资料、程序等都在组织内部。
- 混合云[Hybrid Cloud]
    结合公用云和私有云，使用者将非关键部分外包，置于公用云上处理，
    将关键服务和资料放在私有云内。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：信息来自互联网，图片来源于wikipedia。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>alone</title>
   <link href="http://shawzt.github.com/blog/12-17-2012/alone"/>
   <updated>2012-12-17T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-17-2012/alone</id>
   <content type="html">&lt;p&gt;一个人在雨夜校园里走着，没有人会知道。 &lt;br/&gt;
今天的心情很低落，说不出缘由。只是心里空空的，脑子似乎在快速地搜索着什么，却没有任何的呈现，只是空空的。就像一个人被扔在一个大海深处的小船上，没有恐惧，没有方向，没有指引，只是那么漂着……&lt;br/&gt;
自从来到宁波进入所谓的研究生阶段，这样的状态已出现了很多次。时常会想起四年大学生活中的场景，那时的自己很清楚自己需要什么，即使有时会感觉到累，却不会这样迷惘。如今的生活已与我的预期偏离的太多，找不到属于自己的节奏，浅浅地感到疲惫、迷惘。时常会质疑自己，当初选择的初衷是什么？如今的生活是否是自己真正想要的？现在的我已渐渐失去了自己……&lt;br/&gt;
每次都很想找个人聊聊，每次都选择了一个人承担。不是不相信，也不是不愿意，只是这种状态，这种心情，别人无法真正地体会。&lt;br/&gt;
一个人的生活，冷寂。&lt;br/&gt;
一个人的生活，疲惫。&lt;br/&gt;
一个人的生活，迷惘。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>算法_平面划分</title>
   <link href="http://shawzt.github.com/blog/12-16-2012/algorithm_2"/>
   <updated>2012-12-16T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-16-2012/algorithm_2</id>
   <content type="html">&lt;p&gt;在程序设计竞赛中，很多的题目是考查递归、递推算法的分析与设计能力，其中有些会涉及几何方面。现总结一下我所做过的该类型题目：&lt;/p&gt;

&lt;h3&gt;直线划分平面&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 描述&lt;/strong&gt; &lt;br/&gt;
一条直线可以讲平面划分为2个部分，两条则可以分成4个部分，问：n条直线最多可将平面划分成几个部分？ &lt;br/&gt;
&lt;strong&gt;2. 解析&lt;/strong&gt; &lt;br/&gt;
&lt;img src=&quot;/assets/images/line_div_plane.png&quot; alt=&quot;直线划分平面&quot; /&gt;  &lt;br/&gt;
通过上图分析，可以得出递推公式：f(n)=f(n-1)+n。  &lt;br/&gt;
&lt;strong&gt;3. 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &lt;code class=&quot;language-cpp&quot;&gt;
//递归实现
int divByLine(int num)
{
    if(num == 1)
        return 2;
    else
        return divByLine(num-1)+num;
}
//递推实现
int divByLine(int num)
{
    int* data = new int[num+1];
    for(int i=0; i&lt;=num; i++)
    {
        data[i] = 0;
    }
    data[1] = 2;
    for(int i=2; i&lt;=num; i++)
    {
        data[i] = data[i-1]+i;
    }
    return data[num];
}
    &lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;折线划分平面&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 描述&lt;/strong&gt; &lt;br/&gt;
一条折线可以讲平面划分为2个部分，两条则可以分成7个部分，问：n条折线最多可将平面划分成几个部分？（折线样式如下图所示）&lt;br/&gt;
&lt;strong&gt;2. 解析&lt;/strong&gt; &lt;br/&gt;
&lt;img src=&quot;/assets/images/polyline_div_plane.png&quot; alt=&quot;折线划分平面&quot; /&gt;  &lt;br/&gt;
通过上图分析，可以得出递推公式：f(n)=f(n-1)+4*(n-1)+1。  &lt;br/&gt;
&lt;strong&gt;3. 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &lt;code class=&quot;language-cpp&quot;&gt;
//递归实现
int divByPolyLine(int num)
{
    if(num == 1)
        return 2;
    else
        return divByPolyLine(num-1)+4*(num-1)+1;
}
//递推实现
int divByPolyLine(int num)
{
    int* data = new int[num+1];
    for(int i=0; i&lt;=num; i++)
    {
        data[i] = 0;
    }
    data[1] = 2;
    for(int i=2; i&lt;=num; i++)
    {
        data[i] = data[i-1]+4*(i-1)+1;
    }
    return data[num];
}
    &lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;封闭曲线划分平面&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 描述&lt;/strong&gt; &lt;br/&gt;
一条封闭曲线可以讲平面划分为2个部分，两条则可以分成4个部分，问：n条封闭曲线最多可将平面划分成几个部分？ &lt;br/&gt;
&lt;strong&gt;2. 解析&lt;/strong&gt; &lt;br/&gt;
&lt;img src=&quot;/assets/images/curve_div_plane.png&quot; alt=&quot;封闭曲线划分平面&quot; /&gt;
通过上图分析，可以得出递推公式：f(n)=f(n-1)+2*(n-1)。&lt;br/&gt;
&lt;strong&gt;3. 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &lt;code class=&quot;language-cpp&quot;&gt;
//递归实现
int divByCurve(int num)
{
    if(num == 1)
        return 2;
    else
        return divByCurve(num-1)+2*(num-1);
}
//递推实现
int divByCurve(int num)
{
    int* data = new int[num+1];
    for(int i=0; i&lt;=num; i++)
    {
        data[i] = 0;
    }
    data[1] = 2;
    for(int i=2; i&lt;=num; i++)
    {
        data[i] = data[i-1]+2*(i-1);
    }
    return data[num];
}
    &lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>算法_最大公约数&最小公倍数</title>
   <link href="http://shawzt.github.com/blog/12-15-2012/algorithm_1"/>
   <updated>2012-12-15T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-15-2012/algorithm_1</id>
   <content type="html">&lt;h3&gt;最大公约数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 概念&lt;/strong&gt;&lt;br/&gt;
给出三个正整数a、b、c，若b能够同时整除a、c，那么b就是a、c的公约数；如此a、c的公约数中的最大的一个即叫其最大公约数[Greater Common Divisor——GCD]。例：GCD(12,8)=4&lt;br/&gt;
&lt;strong&gt;2. 算法&lt;/strong&gt;&lt;br/&gt;
欧几里德算法：用较大的数除以较小的数，再将较小的除数和得出的余数构成新的一对数，继续做上面的除法，直到出现能够整除的两个数，则较小的数（即除数）就是最大公约数&lt;br/&gt;
&lt;strong&gt;3. 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &lt;code class=&quot;language-cpp&quot;&gt;
int GCD(int a,int b)
{
    int r = a%b;
    while(r != 0)
    {
        a = b;
        b = r;
        r = a%b;
    }
    return b;   
}
    &lt;/code&gt;
&lt;/pre&gt;


&lt;h3&gt;最小公倍数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 概念&lt;/strong&gt;   &lt;br/&gt;
给出两个正整数a、b、c，若c能够通过被a、b整除，那么c就是a、b的公倍数；如此a、b的公倍数中最小的一个即叫其最小公倍数[Least Common Multiple——LCM]。例：LCM(6,8)=24&lt;br/&gt;
&lt;strong&gt;2. 算法&lt;/strong&gt; &lt;br/&gt;
两个数的乘积/两个数的最大公约数&lt;br/&gt;
&lt;strong&gt;3. 代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &lt;code class=&quot;language-cpp&quot;&gt;
int LCM(int a,int b)
{
    int r = GCD(a,b);
    return a*b/r;   
}
    &lt;/code&gt;
&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>利用Jekyll+Git+GitHub组合，创建自己的博客</title>
   <link href="http://shawzt.github.com/blog/12-14-2012/build_blog"/>
   <updated>2012-12-14T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-14-2012/build_blog</id>
   <content type="html">&lt;h3&gt;&lt;strong&gt;导言&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;很多人都有写博客的冲动，可是只有很少一部分的人会坚持着。究其原因，可能有很多。但是我个人觉得大多数都是因为没有找到一个真正属于自己的博客：要么是有植入性的广告、要么是简陋的设计、要么是繁琐的操作。。。反正就是没法让人满意，我们没法真正地控制自己的博客：我要设计自己的页面、我要创建自己的分类、我要添加自己的插件。。。&lt;br/&gt;
现在，这些烦恼都可以抹去了。利用Jekyll+Git+GitHub组合，可以创建一个托管的却可以自己控制的博客了。你现在你访问的博客，就是使用上述组合实现的。下面，我就根据一些教程并结合自己的实践，整理出利用上述组合搭建博客的步骤及注意点。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;实践&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;一.创建GitHub账户及项目库&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 访问[GitHub]:&amp;lt;https://github.com/&amp;gt;，并根据要求创建账户(已有账户则跳过)，见图1；
2. 登录GitHub后，创建一个Repository：UserName.github.com，
    (注意：UserName替换成你在GitHub上的用户名)，见图2；
3. 该阶段工作完成！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图1：&lt;br/&gt;
&lt;img src=&quot;/assets/images/github.png&quot; alt=&quot;注册GitHub账号&quot; /&gt;&lt;br/&gt;
图2：&lt;br/&gt;
&lt;img src=&quot;/assets/images/createRepo.png&quot; alt=&quot;添加SSH Key&quot; /&gt;&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;二.Git客户端安装及其配置&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 在Linux系统上，可以使用apt-get install git-core安装；
2. 主要介绍Windows系统下的安装和配置，我使用的是MsysGit；
3. MsysGit可从这里下载：&amp;lt;http://code.google.com/p/msysgit/downloads/list&amp;gt;；
4. 根据安装向导，Next--&amp;gt;Next--&amp;gt;……--&amp;gt;Finish；
5. 相关配置，打开Git Bash(注意：该控制台对中文支持不好!)：
    5.1 生成SSH Key：输入ssh-keygen -C &quot;你的email地址&quot; -t rsa;
    5.2 提示生成rsa密钥对，选择密钥文件保存位置(默认即可)及加密串
        (警告:该加密串将是你以后提交时的密码。若无需密码，回车即可)；
    5.3 密钥生成。接下来是将公钥信息添加到GitHub上，用于SSH链接；
    5.4 用文本编辑工具打开刚保存的id_rsa.pub文件(可能会被隐藏),做如下操作：
        Ctrl+A--&amp;gt;Ctrl+C--&amp;gt;登录GitHub--&amp;gt;点击右上角的Account Settings--&amp;gt;
        点击左侧SSH Keys--&amp;gt;点击右侧Add SSH Key--&amp;gt;输入该密钥的标识名(Title)--&amp;gt;
        在Key对应的文本域中Ctrl+V，将上述文件中的信息粘贴进去--&amp;gt;点击Add Key保存；
    5.5 在Git Bash中，输入ssh -T git@github.com，出现提示，输入 yes后将会看到
        授权链接成功的信息；
    5.6 以上步骤已基本配置好Git客户端和GitHub的链接；接下来完善使用配置；
    5.7 在Git Bash中，输入git config --global user.name &quot;你的名字&quot;；
    5.8 在Git Bash中，输入git config --global user.email &quot;你的email&quot;；
    5.9 以上两条配置是用于GitHub的权限处理以及Git对提交信息的记录，基本配置完成。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;三.安装依赖软件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 安装Ruby：&amp;lt;http://rubyinstaller.org/downloads/&amp;gt;，在RubyInstallers下选择；
2. 安装DevKit：&amp;lt;http://rubyinstaller.org/downloads/&amp;gt;，在Development Kit下选择；
3. 安装Jekyll：在Git Bash中，输入gem install jekyll或者sudo gem install jekyll；
4. 安装MarkDown语言的解析器：在Git Bash中，输入gem install rdiscount kramdown；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;四.创建博客&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 在Git Bash中，输入如下命令：
    git clone https://github.com/plusjade/jekyll-bootstrap.git 目标位置
    该命令是将GitHub上jekyll-bootstrap项目克隆至本机的目标位置(建议以英文命名)；
2. cd 目标位置 (说明：目标位置将是你的博客在本机的副本)；
3. git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git
    (说明：USERNAME是你在GitHub上的用户名，USERNAME.github.com将是你的博客地址)；
4. git pull;
5. git push origin master;
6. 博客已创建好，接下来的工作就是学习该组合相关知识，弄懂博客结构，然后就坚持写作吧！
7. 小贴士：在Git Bash中，输入如下命令：
    export LC_ALL=en_US.UTF-8
    export LANG=en_US.UTF-8
    以上两条命名，是为了解决本机中文博客无法预览的问题，但是若不想每次启动Git Bash时
    都输入上述命令，则可以采用以下方法：添加两对用户自定义的环境变量
    LC_ALL=en_US.UTF-8和LANG=en_US.UTF-8
    (提示：Windows--&amp;gt;环境变量)
    cd目标位置；输入 jekyll --server
    在浏览器中输入http://localhost:4000/可以预览你的博客了O(∩_∩)O~
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;资料&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;No1. Git&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;http://rogerdudler.github.com/git-guide/index.zh.html&amp;gt;
2. &amp;lt;http://git-scm.com/&amp;gt;
3. &amp;lt;https://github.com/progit/progit&amp;gt;
4. &amp;lt;https://github.com/blynn/gitmagic&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;No2. GitHub&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;https://github.com&amp;gt;
2. &amp;lt;https://help.github.com/&amp;gt;
3. &amp;lt;https://github.com/blog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;No3. Jekyll&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;http://jekyllbootstrap.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;No4. Liquid&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;https://github.com/Shopify/liquid/wiki&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;No5. MarkDown&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;lt;http://wowubuntu.com/markdown/index.html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>博客 On GitHub</title>
   <link href="http://shawzt.github.com/blog/12-13-2012/blog_online"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://shawzt.github.com/blog/12-13-2012/blog_online</id>
   <content type="html">&lt;h2&gt;博客上线啦&lt;/h2&gt;

&lt;p&gt;&lt;font family=&quot;仿宋&quot; size=&quot;3&quot;&gt;作为一名典型的程序猿，一直想有个自己可以控制的博客。所谓“控制”，就是在闲来无事时可以Designing &amp;amp; Coding，使得博客呈现出自己想要的样式。如今，美好的希望终于实现了。&lt;br/&gt;
前几天，无意中在实验室的博客上看到&lt;a href=&quot;http://www.sunfanwu.com/&quot;&gt;fanwu&lt;/a&gt;同学的“GitHub上搭建博客”的文章，内心顿时澎湃了，接着就是Google、Baidu找资料。&lt;em&gt;不得不吐槽一下：Baidu搜索真的不给力，没法跟Google相比。&lt;/em&gt;通过两三天的折腾，终于将博客搭建成功，理清了Jekyll+Git+Github组合及其使用，并顺利地对博客进行了个性化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;感谢Jekyll &amp;amp;&amp;amp; Git &amp;amp;&amp;amp; Github&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这几天花了好多时间来折腾，终于有了成果，还是很开心的。程序猿嘛，就是如此，成就感和满足感那是别人感受不到的。接下来，会需要继续学习Jekyll、Liquid、MarkDown、以及Git相关知识，任务还是蛮重的。因为一不能耽误学业，二不能影响Boss的项目。(⊙o⊙)…&lt;/p&gt;

&lt;p&gt;这两天会抽点时间把博客的搭建过程总结一下，写个简易教程跟大家分享一下。&lt;/font&gt;&gt;&lt;/p&gt;

&lt;h3&gt;欢迎来访&lt;/h3&gt;
</content>
 </entry>
 
 
</feed>